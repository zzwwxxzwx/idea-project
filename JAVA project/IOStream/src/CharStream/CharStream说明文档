3.1 为什么会出现字符流
    由于字节流操作中文不是特别的方便，所以ava就提供字符流
        字符流=字节流+编码表
    用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？
        汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数
3.2 编码表
    基础知识：
        计算机中储存的信息都是用二进制数表示的；我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果
        按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。
        这里强调一下：按照A编码存储，必须按照A编码解析，这样才能显示正确的文本符号。否则就会导致乱码现象
    字符编码：
        就是一套自然语言的字符与二进制数之间的对应规则(A65)
    字符集：
        是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等
        计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码，
        常见字符集有 ASCIIS字符集、 GBXXX字符集、 Unicode字符集等
    ASCIIS字符集：
        ASCII( American Standard Code for Information Interchange,美国信息交换标准代码)：
            是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）
        基本的ASC字符集，使用7位表示一个字符，共128字符。ASC的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。
        是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等.
    GBXXX字符集：
        GB2312:
            简体中文码表。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。
            这样大约可以组合了包含700多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名等都编进去了，
            连在A里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的全角”字符，而原来在127号以下的那些就叫“半角"字符了。
        GBK:
            最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
        GB18030:
            最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等
    Unicode字符集：
        为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码，它最多使用4个字
        节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF32,最为常用的。
        UTF-8编码：
            UTF-8编码：可以用来表示 Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用
            中，优先采用的编码。互联网工程工作小组(IETF)要求所有互联网协议都必须支持UTF-8编码。它使用
            一至四个字节为每个字符编码
        编码规则：
            128个US-ASCII字符，只需一个字节编码
            拉丁文等字符需要二个字节编码
            大部分常用字（含中文），使用三个字节编码
            其他极少使用的 Unicode辅助字符，使用四字节编码
        小结：来用何种规则编码，就要采用对应规则解码，否则就会出现乱码

3.3 字符串中的编码解码问题
    编码：
        byte[] getBytes():使用平台的默认字符集(此处为IDEA平台)将该 String编码为一系列字节，将结果存储到新的字节数组
        byte[] getBytes(String charsetName):使用指定的字符集将该 String编码为一系列字节，将结果存到新的字节数组中
    解码：
        String(byte[] bytes):通过使用平台(此处为IDEA平台)的默认字符集解码指定的字节数组来构造新的String
        String(byte[] bytes, String charsetName):通过指定的字符集解码指定的字节数组来构造新的 String

3.4 字符流中的编码解码问题
    字符流抽象基类
        Reader:字符输入流的抽象类
        Writer:字符输出流的抽类
    字符流中和编码解码问题相关的两个类：
        InputStreamReader
        OutputStreamWriter
3.5 字符流写数据的5种方式
    方法名                                                 说明
    void write(int c)                               写一个字符
    void write(char[] cbuf)                         写入一个字符数组
    void write(char[] cbuf, int off, int len)       写入字符数组的一部分
    void write(String str)                          写个字符串
    void write(String str, int off, int len)        写一个字符串的一部分
    flush()                                         刷新流，还可以继续写数据
    close()                                         关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据

3.6 字符流读数据的2种方式
        方法名                     说明
    int read()              一次读一个字符数据
    int read(char[] cbuf)   一次读一个字符数组数据

案例：字符流输出Java文件
    需求：
        把模块目录下的 ConversionStreamDemo..jav复制到模块目录下的Copy.java
    数据源和目的地的分析
        数据源： src\CharStream\CopySource.txt--读数据--- Reader-- InputStreamReader--- FileReader
        目的地： src\CharStream\CopyDestination.txt--写数据-- Writer-- OutputStreamWriter--- FileWriter
    思路：
        1:根据数据源创建字符输入流对象
        2:根据目的地创建字符输出流对象
        3:读写数据，复制文件
        4:释放资源

3.7 字符缓冲流
    字符缓冲流：
        BufferedWriter:将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可
        以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途
        BufferedReader:从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定
        缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途
    构造方法：
        BufferedWriter(Writer out)
        BufferedReader(Reader in)

3.8 字符缓冲流特有功能
    BufferedWriter:
        void newLine():写一行行分隔符，行分隔符字符串由系统属性定义
    BufferedReader:
        public String readLine():读一行文字。结果包含行的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null

案例：复制Java文件（字符缓冲流特有功能改进版）
    需求：把模块目录下的CopySourceBuffer.txt复制到模块目录下的CopyDestinationBuffer.txt
    思路：
        ①根据数据源创建字符缓冲输入流对象
        ②根据目的地创建字符缓冲输出流对象
        ③读写数据，复制文件
            使用字符缓冲流特有功能实现
        ⑤释放资源

3.9 IO流小结
     略

案例：集合到文件
    需求：把 ArrayList集合中的字符串数据写入到文本文件。要求：每一个字符串元素作为文件中的一行数据
    思路：
    ①创建 ArrayList集合
    ②往集合中存储字符串元素
    ③创建字符缓冲输出流对象
    ④遍历集合，得到每一个字符申数据
    ⑤调用字符缓冲输出流对象的方法写数据
    ⑥释放资源

案例：文件到集合
需求：把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个集合元素
思路：
    ①创建字符缓冲输入流对象
    ②创建 ArrayList集合对象
    ③调用字符缓冲输入流对象的方法读数据
    ④把读取到的字符串数据存储到集合中
    ⑤释放资源
    ⑥遍历集合

案例：点名器
    需求：我有一个文件里面存储了班级同学的姓名，每一个姓名占一行，要求通过程序实现随机点名器
    思路：
        ①创建字符缓冲输入流对象
        ②创建 ArrayList集合对象
        ③调用字符缓冲输入流对象的方法读数据
        ④把读取到的字符串数据存储到集合中
        ⑤释放资源
        ⑥使用 Random产生一个随机数，随机数的范围在：[O,集合的长度)
        ⑦把第6步产生的随机数作为索引到 ArrayList集合中获取值
        ⑧把第7步得到的数据出在控制台

案例：复制单级文件夹
需求：把“src\CharStream\CharStreamCase_复制单级文件夹\CopySourceDir”这个文件夹复制到模块目录下
思路：
①创建数据源目录File对象，路径是src\CharStream\CharStreamCase_复制单级文件夹\CopySourceDir
②获取数据源目录File对象的名称(CopySourceDir)
③创建目的地目录File对象，路径名是模块名+ itcast组成( src\CharStream\CharStreamCase_复制单级文件夹\CopyDestinationDir)
④判断目的地目录对应的File是否存在，如果不存在，就创建
⑤获取数据源目录下所有文件的Fle数组
⑥遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件
    如，数据源文件：src\CharStream\CharStreamCase_复制单级文件夹\CopySourceDir\1.txt
⑦获取数据源文件File对象的名称(1.txt)
⑧创建目的地文件File对象，路径名是目的地目录+mn.jpg组成
    (src\CharStream\CharStreamCase_复制单级文件夹\CopyDestinationDir\1.txt)
    由于文件不仅仅是文本文件，还有图片，视频等文件，所以采用字节流复制文件

案例：复制多级文件夹
需求：把复制到src\CharStream\CharStreamCase_复制多级文件夹\CopyDestinationDir目录下
思路：
    ①创建数据源File对象，路径是src\CharStream\CharStreamCase_复制多级文件夹\CopySourceDir
    ②创建目的地File对象，路径是src\CharStream\CharStreamCase_复制多级文件夹\CopyDestinationDir
    ③写方法实现文件夹的复制，参数为数据源File对象和目的地File对象
    ④判断数据源File是否是目录
        是：
            A:在目的地下创建和数据源Fle名称一样的目录
            B:获取数据源File下所有文件或者目录的File数组
            C:遍历该File数组，得到每一个File对象
            D:把该File作为数据源File对象，递归调用复制文件的方法
        不是：说明是文件，直接复制，用字节流

