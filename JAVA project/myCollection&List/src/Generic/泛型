4.1 泛型概述
    泛型：
        是DK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非的类型
        它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数
        一提到参数，最熟恶的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢?
        顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型
        这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口
    泛型定义格式：
        <类型>：指定一种类型的格式。这里的类型可以看成是形参
        <类型1，类型2…>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参
        将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型
    泛型的好处：
        把运行时期的问题提前到了编译期间
        避免了强制类型转换

4.2 泛型类
    泛型类的定义格式：
        格式：修饰符 class类名<类型>{}
        范例：public class Generic<T>{}
            此处T可以随便写为任意标识，常见的、E、K、V等形式的参数常用于表示泛型

4.3 泛型方法
    泛型方法的定义格式：
        格式：修饰符<类型>返回值类型方法名(类型变量名){}
        范例： public<T> void show(T t)()

4.4 泛型接口
    泛型接口的定义格式：
        格式：修饰符 interface接口名<类型>{}
        范例： public interface Generic<T>{}

4.5 类型通配符
    为了表示各种泛型List的父类，可以使用类型通配符
        类型通配符：<?>
        List<?>:表示元素类型未知的List,它的元素可以匹配任何的类型
        这种带通配符的List仅表示它是各种泛型List的父类，并不能把元索添加到其中
    如果说我们不希望List<?>是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限
        类型通配符上限：<? extends类型>
        List<? extends Number>:它表示的类型是 Number或者其子类型
    除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限
        类型通配符下限：<? super类型>
        List<? super Number>:它表示的类型是 Number或者其父类型

4.6 可变参数
    可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了
        格式：修饰符返回值类型方法名(数据类型…变量名){}
        范例： publicstaticint sum(int...a){}
    可变参数注章事项
        这里的变量其实是一个数组
        如果一个方法有多个参数，包含可变参数，可变参数要放在最后

4.7可变参数的使用
    Arrays_工具类中有一个静态方法：
        public static<T>List<T> asList(T... a):返回由指定数组支持的固定大小的列表
        返回的集合不能做增删别操作，可以做修改操作
    List接口中有一个静态方法：
        public static<E>List<E>of(E... elements):返回包含任意数量元索的不可变列表
        返回的集合不能做增删改操作
    Set接口中有一个静态方法：
        public static<E>Set<E>of( E... elements):返回一个包含任意数量元索的不可变集合
        在给元素的时候，不能给重复的元素
        返回的集合不能做增删操作，没有修改的方法